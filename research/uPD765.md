## I/O Mapping
 - Port E0h: FDC TC Signal Off
 - Port E2h: FDC TC Signal On
 - Port E4h: Main Status Register (Input only)
 - Port E5h: Data Register (Read/Write)
 - Port E6h: FDC Control Port
## Assembly code
### First code related to FDC
```asm
D1D6: ld a, (0xD00E)
D1D9: dec a
D1DA: cp 0x10
D1DC: jr nc, -18
D1DE: ld a, (0xD00F)
D1E1: cp 0x02
D1E3: jr nc, -25
D1E5: ld a, (0xD00D)
D1E8: cp 0x23
D1EA: jr nc, -32
D1EC: ld a, (0xD007)
D1EF: ld (0xD011), a
D1F2: call 0xD47A
D1F5: ld a, (0xD017)
D1F8: or a
D1F9: jr z, 8
D1FB: in a, (0xE4)      ; <-- First call
D1FD: or a
D1FE: jr z, 3
D200: inc a
D201: jr nz, 63
D203: out (0xE6), a
D205: dec a
D206: ld (0xD018), a    ; Write 4 consecutive bytes
D209: ld (0xD019), a    ; Each byte have value of A
D20C: ld (0xD01A), a
D20F: ld (0xD01B), a
D212: in a, (0xE4)
D214: inc a
D215: jr nz, 9
D217: call 0xD46A
D21A: ld (hl), 0xFF
D21C: ld a, 0x30
D21E: jr -82
D220: dec a
D221: jr nz, 27
D223: call 0xD755
D226: out (0xE6), a
D228: in a, (0xE4)
D22A: or a
D22B: jr nz, 17
D22D: ld a, 0x80
D22F: out (0xE6), a
D231: call 0xD755
D234: out (0xE6), a
D236: in a, (0xE4)
D238: inc a
D239: jr z, -36
D23B: dec a
D23C: jr z, -39
D23E: xor a
D23F: ld (0xD017), a
D242: ld a, (0xD017)
D245: or a
D246: jr nz, 10
D248: call 0xD49C
    D49C: call D65B     ; See the code block below for their functionality
```
### Clear Interrupt Queue
```asm
D65B: ld b, 0x08    ; Sense Interrupt Status opcode
D65D: call 0xD68B   ; Send "Status Register Status" command
D660: ret c         ; Error: no FDC Present
D661: call 0xD6A2   ; Read first response byte
D664: ret c         ; Error
D665: and 0xC0      
D667: cp 0x80
D669: ret z         ; If (A & 0xC0) == 0x80, return (real exit)
D66A: call 0xD6A2   ; Read second response byte
D66D: ret c         ; Error
D66E: jp 0xD65B     ; Loop again if more interrupts
```
### Unknown
```asm
D671: call 0xD67B
D674: ret c
D675: ld a, (0xD008)
D678: ld b, a
D679: jr 16
D67B: ld a, b
D67C: ld (0xD012), a
D67F: jr 10
```

### Send command with polling
```asm
D68B: in a, (0xE4)
D68D: cp 0xFF   ; Maybe no FDC present
D68F: jr z, 8   ; If yes, go to 0xD699 (Reset FDC)
D691: and 0xC0  ; Mask 0b11000000
D693: cp 0x80   ; If RQM = 1, DIO = 0
D695: jr z, 7   ; If yes, go to 0xD69E (send command)
D697: jr c, -14 ; If no, loop back and try again

D699: call 0xD746
D69C: scf       ; This was used like a flag to indicate error
D69D: ret 
```

### Reset FDC
```asm
D746: ld a, 0x80    ; 1000 0000
D748: out (0xE6), a ; Send to FDC Control port
D74A: xor a
D74B: ld (0xD017), a
D74E: nop 
D74F: nop 
D750: nop 
D751: nop 
D752: nop 
D753: nop 
D754: ret 
```

### Send Command
```asm
D69E: ld a, b       ; Load reg A with a command opcode
D69F: out (0xE5), a ; Send command
D6A1: ret 
```
### Read a byte from Data Register
```asm
D6A2: in a, (0xE4)
D6A4: cp 0xFF
D6A6: jr z, -15     ; Not ready, go reset FDC (0xD699)

D6A8: cp 0xC0       ; If status < 0xC0
D6AA: jr c, -10     ; If not ready, poll again (jump to 0xD6A2)
D6AC: in a, (0xE5)  ; If ready (RQM = 1, DIO = 1), read a byte
D6AE: ret 
```
